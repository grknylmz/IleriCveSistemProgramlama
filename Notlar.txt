/////////////////////////////////////  Ýleri C ve Sistem Programlama ///////////////////////////////////////////////////////
///////////////////////////////////// 16.05.2015 ////////////////////////////////////////////////////////////////////////////////////

bit.do/SysProg-2015

Bazý Ýleri C konularý
Veri yapýlarý ve algoritma
Disk Ýþlemleri
TCP-IP Client Programlama
Recursive Algoritmalar
Derleyici Yazým Ýlkeleri
Ýþletim sistemlerinin aþaðý seviyeli incelenmesi
Proseslerarasý haberleþme
Interruption
SeriPort - Paralel Port USB Haberleþme
Test Ýþlemleri
Gui Programlama modulu altyapýsý
Koruma Mekanizasý
Bellek Yönetimi
Threadler


GCC gnuCCompiler
GCC GnuCompilerCollection
Understand ---> Linux Source code duzenlemeyici vs.


Programlamadaki Katmanlý Yapýlar

Bazı az bilinen C fonksiyonları

RENAME Fonksiyonu
#include <stdio.h>

int rename(consy char *old, const char *new)
Başarı durumunda 0 değerine başarısızlık durumunda -1 değerine döner.

Örneğin;
int main(void){
if(rename("test.txt" , "x.txt") == -1 )
printf("Cannot change name!");

printf("Change successful!");

}

SYSTEM Fonksiyonu

System fonksiyonu kabuk programı interaktif olmayan modda çalıştırarak parametresi ile belirtilen kabuk komutunun kabuk tarafından çalıştırılmasını sağlar.
Fonksyonun prototipi



#include <stdlib.h>
int system(const char *string)

Fonksiyon parametre olarak kabuk komutunu yazı olarak alır.Fonksiyon geri dönüş değeri sistemden sisteme değişebilmektedir.Pekçok sistemde fonksiyon başarı durumunda
sıfır başarısızlık durumunda -1 değerine geri döner.


#include <stdlib.h>
int main(void){
    int result;

    result = system("ren x.txt a.txt");

    printf("%d\n",result);

}

Geçici Dosya Kavramı ve Geçici Dosya Oluşturan fonksiyonlar

Diyezli ifadeli yada dolarlı ifadeli dosyalar temporary dosyalardır.

TMPFILE Fonksiyonu

#include <stdio.h>
FILE *tmpfile(void);

Fonksiyon "w+b" modunda yeni bir dosyayı çakışma riski olmadan yeni bir dosyayı yaratır. Bize dosya bilgi göstericisi ile geri döner.
Biz dosyayı kullandıktan sonra onu fclose ile kapatırız bu durumda dosya otomatik olarak silinmektedir.

EXIT islemi sırasında bütün dosyalar standart olarak kapatılıyor.

#include <stdio.h>
int main(void){
    FILE *f;
    
    if((f = tmpfile()) == NULL){
        fprintf(stderr , "cannot create temporary file ...\n");
        exit(EXIT_FAILURE);
        
        
    }
    
    
    for(i = 0 ; i<100 ; i++){
        if(fwrite(&i , sizeof(int) , 1 , f ) != 1){
            fprintf(stderr , "cannot create temporary file ...\n");
            exit(EXIT_FAILURE);
        }
    }
    
    
    fseek(f,0,SEEK_SET);
    
    while(fread(&val , sizeof(int) , 1 , f)){
            fprintf(stderr , "cannot create temporary file ...\n");
            exit(EXIT_FAILURE);
        }
    }


    if(ferror(f))
    fprintf(stderr,"cannot read file");


    fclose(f);
    
    return 0;

}




TEMPNAM Fonksiyonu

Dosyaya çakışmayacak isim veriyor.

prototipi
#include <stdio.h>
char *tmpnam(char *s);  /// Başarısızlık durumunda null pointer a geri döner.

Parametre olarak bizden geçici dosya isminin yerleştirileceği dizinin adresini ister. Bu durumda fonksiyon kendi içerisindeki static bir diziye dosya ismini yerleştirir ve onun adresiyle
geri döner.


int main(void){
    
    FILE *f , *ftemp;
    char *ftempnam;
    
    
    if(argc != 2){
        fprintf(stderr , "wrong number of arguments!!");
        exit(EXIT_FAILURE);
    }
    
    if((f = fopen(argv[1],"r"))  == NULL){
        fprintf(stderr, "cannot open file");
    }
    
    
    
    return 0;


}


Dosyayı kapatmadan rename edemeyiz.


//////////////////////13.06.2015
#include <dirent.h>
struct dirent *readdir(DIR *dirp);

Fonksyion opendrir fonksiyonundan elde edilen DIR türünden adresi paramaetre olarak alır ve struct dirent türünden static ömürlü 
bir yapı nesnesinin adresiyle
geri döner . Dizin listesinin sonuna gelinmiş ise NULL adresiyle geri döner.

Çeşitli UNIX turevi sistemler bu yapıya eklenti biçiminde eleman ekleyebilmektedir. Ancak POSIX standartlarında yapı böyle bildirilmiştir.
Görüldüğü gibi readdir bize dosyanın isminden ve i-node numarasından başka birşey vermemektedir. i-node numarasının ne anlam ifade ettiği ileride ele
alınacaktır. i-node numarası dosyayı betimleyene sistem genelinde tek olan (unique) bir numaradır.

while((dire = readdir(dir)) != NULL)
	printf("s\n" , dire->d_name);

İşlem bitince closedir fonksiyonuyla açılan dizi kapatılır. Tabi dosyalarda olduğu gibi biz bunu kapatmamışsak process sonlandığında dizin sorunsuz olarak
işletim sistemi tarafından kapatılmaktadır.

#include <dirent.h>
int closedir(DIR *dirp);

Fonksiyon başarı durumunda sıfır başarısızlık durumunda -1 döner. Başarının kontrol edilmesine gerek yoktur.

stat POSIX Fonksiyonu
Bir dosyanın yol ifadesi biliniyorsa onun bilgilerini elde etmek için stat fonksiyonu kullanılmaktadır. Stat fonksiyonun fstat ve lstat isimli kardeşleri de 
vardır . stat fonksiyonu UNIX türevi sistemler için çok önemli bir Fonksyiondur.

man stat
man 2 stat


#include <sys/stat.h>

int stat(const char *path, struct stat *buf);

fonksiyonun birinci parametresi bilgisi elde edilecek dosyanın yol ifadesini alır. İkinci parametre dosya bilgilerinin yerleştirileceği
struct stat türünden yapı nesnesinin adresini almaktadır.Fonksyionun geri dönüş değeri başarılı ise 0 başarısız ise -1 olur. Stat yapısı sys/stat.h içerisinde
aşağıdaki gibi bildirilmiştir.

 struct stat {
               dev_t     st_dev;         /* ID of device containing file */
               ino_t     st_ino;         /* inode number */
               mode_t    st_mode;        /* protection */
               nlink_t   st_nlink;       /* number of hard links */
               uid_t     st_uid;         /* user ID of owner */
               gid_t     st_gid;         /* group ID of owner */
               dev_t     st_rdev;        /* device ID (if special file) */
               off_t     st_size;        /* total size, in bytes */
               blksize_t st_blksize;     /* blocksize for filesystem I/O */
               blkcnt_t  st_blocks;      /* number of 512B blocks allocated */

               /* Since Linux 2.6, the kernel supports nanosecond
                  precision for the following timestamp fields.
                  For the details before Linux 2.6, see NOTES. */

               struct timespec st_atim;  /* time of last access */
               struct timespec st_mtim;  /* time of last modification */
               struct timespec st_ctim;  /* time of last status change */

           #define st_atime st_atim.tv_sec      /* Backward compatibility */
           #define st_mtime st_mtim.tv_sec
           #define st_ctime st_ctim.tv_sec
           };



Yapinin elemanlari onemli bilgiler vermktedir. Ancak bu elemanlar kursun bu noktasinda incelenmeyecektir. Fakat yapının st_size elemani dosyanin
uzunlugunu , st_atime, st_mtime, ve st_ctime elemanlari dosyanin erisim zamanlarini bize verir. off_t isaretli bir tamsayi turundendir.time_t ise
01/01/1970 tarihinden gecen saniye sayisini belirten aritmetik bir turdur.





#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>





int main(void){

	struct stat info;

	if(stat("/usr/include/stdio.h", &finfo) < 0 ){

		perror("stat");
		exit(EXIT_FAILURE);

	}

	printf("%ld\n" , finfo.st_size);
	printf("%s\n", ctime(&finfo.st_mtime) );

	return 0;
}



ctime() yazı olarak statik bir char dizisine aldığı veriyi yazı olarak koyup geri döndürüyor.


fonksiyonlar icin hata kontrolleri
Hata kontrolü bakımından fonksiyonları X gruba ayırabiliriz;
1)Hata kontrolunun yapılması gereken gonksyionlar : Bunlar sistemin o anki durumuyla ilgili biçimde başarısız olabilecek fonksiyonlardır . Bu tür 
fonksiyonlar çağrılırken kesinlikle hata kontrolü yapılmalıdır. Öreneğin fopen, malloc gibi fonksiyonlar.
2)Eğer programcı herşeyi düzgün yapmışsa başarısız olma olasılığı olmayan fonksyonlar için hata kontrolü yapılmayabilir. Örneğin dosya fopen ile düzgün açılmışsa
fclose ile kapatılmamaısının bir nedeni olmaz zaten böyle birşey olsa bile bizim yapabileceğimiz birşey de yoktur.
Bu tür fonksiyonlarda hata kontrolü programın DEBUG versiyonunda yapılabilir.

HANDLE SİSTEMLERİ

HANDLE türü void*  macar notasyonu -> hFileFind şeklinde ifadeler kullanılır.
HANDLE bir tamsayı biçiminde olabilir.

int fd;

fd = open("sdkmakls");

Handle bir veri yapısına erişmekte kullanılan tekil bir anahtar değerdir. Handle bir tamsayı biçiminde olabilir. Bu durumda muhtemelen handle global bir dizide
bir indeks belirlemektedir. Handle bir adres biçiminde olabilir. Bu durumda doğrudan bir veri yapısını gösterir. Bazen handle void bir adres olarak karşımıza çıkabilir.
Bu durumda o adresin gösterirdiği yerde bir veri yapısı verdır. Fakat sistemi tasarlayan kişi bunu açıklamak istememiştir. Bazen handle bozulmuş bir biçimde
bize verilir. Sistem onu düzelterek veri yapsına erişir. Böylece kullanan kişi oraya erişmemiş olur. Handle ile erişilen veri yapısına handle alanı denilmektedir.



Bir handle sisteminde 3 grup fonksiyon bulunur. 
	1) Handle sistemlerini yaratan yada açan fonksiyonlar : Bunlar genellikle özellikle windows sistemlerinde CreateXXX yada OpenXXX biçiminde isimlendirilir.
Bu fonksiyonlar veri yapısını oluşturur, tahsis eder . onun elemanlarına çeşitli ilkdeğerleri verirler ve handle ile geri dönerler.

handle ----> handle alani 

	2) Handle sistemini kullanan fonnksiyonlar : Bunlar handle değerini bizden alıp veri yapısına erişerek oradaki bilgileri kullanarak faydalı işlem yaparlar.
	3) Handle sistemini kapatan fonksiyonlar : Bunlar handle alanını boşaltıp birtakım son işlemleri yaparlar. Windows sistemlerinde genellikle bu fonksiyonlar
CloseXXX ya da DestroyXXX biçiminde isimlendirilmektedir.

Örneğin fopen handle sistemini açan bir fonksiyondur. Bize handle değerini FILE* biçiminde verir. fgetch, fread gibi fonksiyonlar handle sistemini kullanan 
fonksiyonlardır. fclose da handle sistemini kapatan Fonksyiondur Ya da örneğin FindFirstFile handle alanını yaratır , bize o alanın adresini void* olarak verir.
FindNextFile handle sistemini kullanan bir fonksiyondur. FindClose ise handle sistemini kapatan fonksiyondur. 



#include <stdio.h>
#include <stdlib.h>

typedef int DATATYPE;


typedef struct tagMATRIX{

	size_t rowsize;
	size_t colsize;
	DATATYPE *pMatrix;

} MATRIX, *HMATRIX;

HMATRIX CreateMatrix(size_t rowsize, size_t colsize);
void SetMatrix(HMATRIX hMatrix);
void CloseMatrix(HMATRIX hMatrix);
DATATYPE GetElem(HMATRIX hMatrix, size_t rowsize , size_t col);
void PutElem(HMATRIX hMatrix, size_t row, size_t col, DATATYPE val );
void DispMATRIX(HMATRIX hMatrix);

HMATRIX CreateMatrix(size_t rowsize , size_t colsize){
	HMATRIX hMatrix;
	if((hMatrix = (HMATRIX) malloc(sizeof(MATRIX))) == NULL)
		return NULL;

	hMatrix->rowsize = rowsize;
	hMatrix->colsize = colsize;

	if((hMatrix->pMatrix = (DATATYPE *)malloc(rowsize*colsize*sizeof(DATATYPE))) == NULL){
		free(hMatrix);

		return NULL;

	}

	return hMatrix;
}


Handle sistemleri nesne yönelimli programlama tekniğinideki sınıflara oldukça benzemektedir. Başka bir deyişle biz nesne yönelimli teknikte bir handle sistemini bir sınıf olarak 
tasarlayabilriz. Şöyleki Handle alanı sınıfın private veri elemanları olarak bildirilir. Sınıfın üye fonksiyonları bunları ortak kullanmaktadır.




Özyinelemeli Algoritmalar ve fonksiyonlar

Özyinelemeli bir olgunun kendisini ya da kendisine benzeyen bir olguyu içermesi durumudur. Özyineleme olgusu hem doğada rastladığımız bir olgudur hem de bilgisayar
bilimlerinde sıklıkla karşılaştığımız bir olgudur. Örneğin bir dizin içerisinde dosyalar ve başka dizinler bulunur. Dizin içerisindeki dizine geçtiğimizde oradada 
benzer yapı karşımıza çıkar . O halde dizin yapısı özyineleme içermektedir.






Tipik özyinelemeli algortimalardan bazıları şuanlardır: 
-Dizi ağacının dolaşılması
-İkili ağaç gibi algortimik ağaçların dolaşılması
-grafların dolaşılması ve graflarda arama
-Parserlar

Özyinelemeli fonksiyonlar
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////


#include <stdio.h>

void foo(void){

	foo();

}


int main(void){

	foo();
	return 0;
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////




#include <stdio.h>

void foo(){

	printf("%d\n", n);
	if(n == 0)
		return;

	foo(n - 1);
	printf("Cikis");

}


int main(){

	foo(3);

	return 0;
}


/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////


#include <stdio.h>

void foo(){

	

}


int main(){

	return 0;
}

Bir fonksiyonun kendini çağırması ile başka bir fonksiyonu çağırması arasında aslında hiçbir farklılık yoktur. Örneğin: 

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////


#include <stdio.h>

void bar(){

	....
	foo();
	....

}



void foo(){
	......
	bar();
	......
	

}


int main(){

	foo();
	return 0;
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////

Burada bar çağrıldığında bar ıın içerisinde yeni bir a stack te oluşturulacaktır. ve bar sona erdiğinde akış çağrılan yerden devam edecektir. 
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////


#include <stdio.h>

long factorial(long n){

	long result ;

	if(n == 0)
		return 1;

	result  = n * factorial(n-1);
	return result;
}


int main(){

	result = factorial(4);
	printf("%ld\n", result );

	return 0;
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////



2. yazının tersten yazdırılma algoritması
Özyineleme düz olan bir şeyi ters çevirmek için sık kullanılmaktadır. Bu problemdede aslında özyinelemeye hiç gerek yoktur. 

Normal  Çözüm

void putsrev(const char *str){
	int i;

	for(i = 0 ; str[i] != '\0' ; ++i )
		;
	for(--i ; i>= 0 ; --i)
		putchar(str[i]);
}

int main(void){
	putsrev("ankara");
}


Özyinelemeli

Ödev Selection sort recursive yap.
Eigth queens algoritmasını yap.

Aslında bilgisayar sitemlerinde ekrana sayı yazdırmak diye birşşey yokyut. Yalnızca ekrana karakterler yazdırılabilir. Bu durumda aslında printf gibi bir fonksiyon
int bir sayıyı yazıdırırken printf sayıyı basamaklarına ayrıştırıp onlara karşılık gelen karakterlleri bastırmaktadır. Yani herşey putchar gibi bir fonksiyonla
yapılır. o halde yalnızca putchar kullanılarak bir sayının yazıdırılaması sistem programlama için önemlidir. Bu işlem tipik olarak recursive olarak 
yapılır. Bu problemin recursive olmayan çözümü recursive çözümünden daha kötüdür. 

#include <stdio.h>

void putnam(int n){
	char s[16];
	int i;

	if(i = 0){
		s[i++] = '-';
	}

	for (int i = 0; i < n; ++i)
	{

		s[i] = n %10;
		n /= 10;

	}


}

unsigned int reverseBits(unsigned int num)
{
    unsigned int  NO_OF_BITS = sizeof(num) * 8;
    unsigned int reverse_num = 0, i, temp;
 
    for (i = 0; i < NO_OF_BITS; i++)
    {
        temp = (num & (1 << i));
        if(temp)
            reverse_num |= (1 << ((NO_OF_BITS - 1) - i));
    }
  
    return reverse_num;
}
 
/* Driver function to test above function */
int main()
{
    unsigned int x = 2; 
    printf("%u", reverseBits(x));
    getchar();
}
Above program can be optimized by removing the use of variable temp. See below the modified code.

unsigned int reverseBits(unsigned int num)
{
    unsigned int  NO_OF_BITS = sizeof(num) * 8;
    unsigned int reverse_num = 0;
    int i;
    for (i = 0; i < NO_OF_BITS; i++)
    {
        if((num & (1 << i)))
           reverse_num |= 1 << ((NO_OF_BITS - 1) - i);  
   }
    return reverse_num;
}


#include <stdio.h>

Çok boyutlu diziler ve dizi göstericileri

int (*p)[6]; Dizi göstericisi

Matrisler aslında dizi dizileridir. Yani dizilerden oluşmuş dizilerdir. Örneğin 

a[3][2];

burada her biri iki elmandan oluşan 3 elemanlı bir dizi dizisi söz konusudur.

int (*p)[2];

Bir dizi göstericisi * operatoruyle erişir isek o nesne belirtmez , dizinin tamamını belirtir. (Tıpkı dizi isimlerinde olduğu gibi.) 
Burada p göstericisinin gösterdiği yerde int bir bilgi yoktur. int türden bir dizi vardır. p göstericisininn türü int[2] biçimindedir. *p bir nesne belirtmez.
*p ifadesini Sanki bir dizi isminin kullanıyormuşuz gibi düşünebiliriz. C'de bir ' dizinin de adresi alınabilir. Dizi adresleri dizi göstericilerine atanır.
Örneğin : int a[2];
int *pi;
int(*pa) = &a;
*pa = 10 /// Geçersiz sanki a = 10 gibi
*pa + 1 ; /// Geçerli , *pa ile belirtilen dizinin sonraki elemanın adresi elde edilir.
**pa = 10; /// Geçerlidir. pa göstericisinin gösterdiği yerdeki dizinin ilk elemanına atanıyor.
*p[2] = 10 ; /// geçerli 2 indeksli elemana atama.



Örneğin 

int a[3][2];

Burada mademki bir diznin ismini işleme soktuğumuzda artık o o dizinin ilk elemanın adresi anlamına geliyor, o halde a ifadesi int[2] türünden bir dizinin 
adresi anlamına gelir. Bu da dizi göstericisine yerleştirilebilir. 

int a[3][2];
int (*pa)[2];

pa = a /// geçerli 

Bir dizi göstericisini 1 arttırdığımızda içindeki adres gösterdiği dizinin uzunluğu kadar artar.

int a[3][2];
int (*pa)[2];

pa = a;  // Burada pa dizi dizisinin 0'ıncı indeksli dizisini göstermektedir //
++pa;	// burada dizi dizisinin 1'inci indeksli dizisini göstermektedir. //


val = pa[1][1] // eşdeğeri (*(pa+2))[1] // 5 Değeri

pi = pa[1];
val = pi[2];


Current Working Directory 

Process'in' çalışma dizini




#include <stdio.h>
#include <Windows.h>

int main(void){
	char cwd[1024];

	GetCurrentDirectory(1024, cwd);
	printf("%s\n" , cwd);

	return 0;
}



Linux / UNIX

man getcwd

#include <unistd.h>

char *getcwd(char *buf, size_t size);

Fonksiyonun birinci parametresi yol ifadesinin yerleştirileceği dizinin adresini ikinci parametresi ise bunun uzunluğunu alır. Fonksiyon birinci parametreyle



Unıx sistemlerde chdir posix fonksiyonu ile yapılır.



İstenildiği kadar \\\\\ kullanılabilir.


Process Çalışmaya Başladığında Çalışma Dizini Nerededir? 
UNIX/Linux sistemlerinde prosesin 



Dizin Ağacının dolaşılması

Recursive bir algoritma 

Fonksiyon çalışma dizininde dosyaları listeleyerek ilerler , tek parametresi vardır , içi listelenecek dizidir. Fonksiyon o dizinin içerisine geçer,
ve dosyaları listelemeye başlar. Fonksyion o dizinin içerisine geçer ve dosyları listelemeye başlar. Bir dizin gördüğünde onu argüman yaparak fonksiyon 
kendini çağırır.


#include <stdio.h>
#include <string.h>
#include <windows.h>

void Disp(const char *path);


void WalkDir(){

}

int main(){


	WalkDir("e:\\" i Disp);

	return 0;
}



fxr.watson.org



void sort(void *base, size_t count , size_t width , int(*cmp)(const void*, const void*)){

}

int main(int argc, char const *argv[])
{
	int a[10] = {34, 23 , 45 , 11, 78, 43, 34, 87, 33, 21};
	sort(a , 10 , sizeof(int) , )
	return 0;
}



setbuf fonksiyonunun ptototopi şöyledir:

#include <stdio.h>

void setbuf(FILE *stream, char *buf);

Fonksiyonunun birinci parametresi tamponlama ile ilgili işlem yapılacak dosya bilgi göstericisini , ikinci parametresi yeni tamponun adresini belirtir. İkinci parametre null
geçilirse sıfır tamponlama söz konusu olur. 

#include <stdio.h>
#include <stdlib.h>


int main(int argc, char const *argv[])
{
	FILE *f;
	char buf[BUFSIZ]

	if((f = fopen("test.txt" , "r") == NULL )){
		fprintf(stderr, "Cannot open file\n");
		exit(EXIT_FAILURE);
	}

	setbuf(f , buf);

	ch = fgetc(f);

	fseek(f, 0 , SEEK_CUR);
	fputc('x'  , f);

	fclose(f);

	return 0;
}

okumadan yazmaya ve yazmadan okumaya geçerken fseek veya flush etmek gerekiyor.


setvbuf fonksiyonunun parametrik yapısı işe şöyledir: 


#include <stdio.h>

int setvbuf(FILE *fstream, char *buf , int mode, size_t size);

fonksiyonun birinci parametresi tamponlama stratejisi değiştirilecek dosyanın dosya bilgi göstericisini belirtir. İkinci parametre dosyanın yeni tamponunu belirtmektedir.
Bu parametre null geçilebilir. Bu durumda tamponun fonksiyonun kendisi tarafından tahsis edileceği anlamına gelir. 3. parametre yeni tamponlama stratejisinin modunu ne olacağını belirtir.
Bu parametre aşağıdaki sembolik sabitlerden biri olarak girilmeilidir. 

_IOFBF (tam tamponlama için )
_IOLBF (Satır tamponlaması için)
_IONBF(Sıfır tamponlama için)

Sonunda yeni tamponun uzunluğunu belirtiyoruz.



#include <stdio.h>
#include <stdlib.h>


int main(int argc, char const *argv[])
{
	FILE *f;
	char buf[BUFSIZ]

	if((f = fopen("test.txt" , "r") == NULL )){
		fprintf(stderr, "Cannot open file\n");
		exit(EXIT_FAILURE);
	}

	setvbuf(f, buf , _IOLBF ,  BUFSIZ)

	fclose(f);

	return 0;
}



fgetc mi getc mi ?

Hızlı okuma yapma için getc kullanılabilir.  Aralarındaki tek fark getc'nin' bir makro olarak yazılmış olabileceğidir. Genellikle getc bir makro olarak yazılır. Böylece bir dosyadan byte 
byte okuma yapılmak iste 


STDERR STDIN STDOUT Nedir ? Aygıt sürücüler Nasıl kullanılır : 






int main(int argc, char const *argv[])
{
	scanf("%d" , &val);
	printf("%d\n", val );
	return 0;
}



./sample < x.txt
./sample > x.txt


Birden fazla yönlendirme beraber de yapılabilir. Örneğin ; 

./sample > x.txt < y.txt

Burada sample programının stdout dosyası x.txr ye stdin dosyası da y.txt ye yönlendirilmektedir.

Anahtar Notlar: Ide'lerde' genel olarak yönlendirme işlemi idelerin menuleri ile yapılabilmektedir. Ornegin visual studio'da' proje ayarlarında Debugging kısmında command 
arguments seçeneğinde yönlendirme ifadelerini girebiliriz.

Şüphesiz programın aynı zamanda komut satırı argümanları da girilebilir. 

Burada "Ali" , "Veli" ,"Selami" programın komut satırı argümanlarıdır. Hata mesajlarını yazdırırken stderr fonksiyonu ile yazdırırsan stdout dan farklı olarak stdout herzaman
ekrana yazı yazdırır fakat stderr ekrana yazdırmaz output a argümanları koymaz.




Böyle bir çalışmada hem programın normal mesajalrı hem de hata mesajları ekran görünür. Fakat 

./sample 2> x.txt // Burada yalnızca progrmaın normal mesajları ekranda görünür. hata mesajları x.txt dosyasına yazdırılmaktadır. Unix Linux sitemlerinde /dev/null isimli dosya bir aygıt
sürücü dosyasıdır. Bu aygıt sürücünün write fonksiyonunun içi boştur. Böylece biz istersek aşağıdaki gibi programın hata mesajlarının kafa karıştırmasını önleyebiliriz.

./sample 2> /dev/null





















